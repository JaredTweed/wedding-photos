<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Maiya & Jared 2025</title>
<style>
:root {
  --primary-color:   hsl(96 23.7% 54%);
  --secondary-color: #e6eef9;
}

body{
  /* turn off the blue tap highlight on iOS/Android */
  -webkit-tap-highlight-color: transparent;
  font-family:system-ui;margin:0;background:#fafafa;color:#222;
position: relative;}

/* floating date indicator */
#dateIndicator {
  position: fixed;
  top: 7rem;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.6);
  color: #fff;
  padding: 0.5rem 1rem;
  border-radius: 1rem;
  font-size: 1rem;
  z-index: 10001;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s;
  text-align: center;
}

body * {-webkit-tap-highlight-color: transparent;}
header{padding:10px;position: relative;display:flex;}
#addBtn{flex: 1;box-shadow:
    0 0 1px rgba(0,0,0,0.15),
    0 6px 12px rgba(0,0,0,0.15); display:block;
    background-color: var(--primary-color);color: white;margin:0;
    padding:0.5rem 1rem;cursor:pointer;width:auto;height:100%;box-sizing: border-box;font-size:1rem; 
    border-radius: 8px; border: none;font-weight: 700; text-align: center;}
#addBtn:active{box-sizing: border-box;
    transform: translateY(2px);}

/* make the tabs container a pill with a glider */
#tabs.tabs {
  margin: 0 10px 10px;
  position: relative;
  display: flex;
  gap: .5rem;
  background: #fff;
  border-radius: 8px;
  box-shadow:
    0 0 1px rgba(0,0,0,0.15),
    0 6px 12px rgba(0,0,0,0.15);
}

#tabs.tabs > * {
border-radius: 8px;
}

/* hide your old borders & backgrounds */
#tabs.tabs .tab-header {
  position: relative;
  z-index: 2;
  flex: 1;
  text-align: center;
  padding: 0.6rem 1rem;
  border: none;
  background: transparent;
  cursor: pointer;
  transition: color .15s ease-in;
}

/* active tab label color */
#tabs.tabs .tab-header.active {
  color: var(--primary-color);
  font-weight: 600;
}

/* the moving “glider” */
#tabs.tabs .glider {
  position: absolute;
  top: 0; bottom: 0;
  width: calc(50% - 5px); /* half width minus half margin */
  background: var(--secondary-color);
  margin: 5px;
  z-index: 1;
  transition: transform .5s ease-out;
}

/* glider position when each tab is active */
#tabAll.active  ~ .glider { transform: translateX(0%); }
#tabMine.active ~ .glider { transform: translateX(100%); }



.tab-header{
    /* turn off the blue tap highlight on iOS/Android */
  -webkit-tap-highlight-color: transparent;
  
  padding:.4rem 1rem;border:1px solid #ccc;border-bottom:none;
            background:#eee;cursor:pointer;border-radius:6px 6px 0 0}
.tab-header.active{background:#fff;font-weight:600}
.tab-panel{display:none}
.tab-panel.active{position: relative;display:grid;
  /* maximize it at 4 to reduce the amount of photos that 
  need to be loaded simultaneously */
  grid-template-columns:repeat(4,minmax(160px,1fr));
                  gap:.75rem;padding:0 10px 2rem;
  overflow-y: auto;
  align-content: start;
  height: calc(100vh - 137px);
    overflow-y: auto;
}
/* on small viewports, fall back to fewer columns */
@media (max-width: 710px) {
  .tab-panel.active {
    grid-template-columns:repeat(auto-fill,minmax(160px,1fr));
  }
}
figure{margin:0;position:relative;
  -webkit-touch-callout: none;   /* iOS Safari */
  touch-action: manipulation;    /* general pointer */}
img,video{box-shadow: 0 4px 10px rgba(0, 0, 0, 0.4);width:100%;aspect-ratio:1/1;object-fit:cover;border-radius:10px;cursor:pointer;}

/* the white “checkbox” */
.select-box {
  position: absolute;
  top: 6px; right: 6px;
  width: 20px; height: 20px;
  border: 2px solid rgba(255,255,255,0.8);
  background: rgba(255,255,255,0.6);
  border-radius: 4px;
  box-sizing: border-box;
  z-index: 3;
}

/* when selected, fill it */
figure.selected .select-box {
  background: #fff;
  box-shadow: 0 0 8px rgba(0, 0, 0, 0.4);
}
figure.selected img:not(.video-icon),
figure.selected video {
  width: calc(100% - 8px);
  border: 4px solid black;
}

.empty-message {
  text-align: center; left: 50%; top: 0; 
  transform: translateX(-50%); width: 100%;
  font-size: 1.2rem;
  position: absolute;
}

/* toolbar at bottom */
#selectionToolbar {
  position: fixed;
  bottom: 0; left: 0;
  width: 100%;
  padding: 0.5rem;
  background: #fff;
  box-shadow: 0 -2px 6px rgba(0,0,0,0.15);
  display: none;
  align-items: center;          /* vertical center */
  justify-content: space-between;
  text-align: center;
  z-index: 20000;
  box-sizing: border-box;
  gap: 0.5rem;
}

#deselectAll {
  font-size: 1.2rem;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  margin: -0.5rem;
  width: 3rem; height: 2rem;
  /* border: 1px solid black; */
}

#selectionToolbar button {
  padding: 0.6rem 0.5rem;
  border: none;
  border-radius: 6px;
  font-weight: 600;
  cursor: pointer;
}
#downloadSelected {
  flex: 1;                      /* take up all available space */
  /* margin-right: 2.5rem; */
  background: var(--primary-color);
  color: #fff;
}

#deleteSelected {
  flex: none;                   /* only as big as its content */
  background: #f44336;
  color: #fff;
}

/* disable text selection on all your tappable controls */
button, label,
.tab-header,
#loadMoreBtn,
#downloadSelected,
#deleteSelected,
#addBtn {
  /* standard */
  user-select: none;
  /* WebKit */
  -webkit-user-select: none;
  /* older IE/Edge */
  -ms-user-select: none;
}


.del{position:absolute;top:4px;right:4px;border-radius:4px;font-size:.75rem;cursor:pointer}
.video-icon {
  position: absolute;
  top: 4px;
  left: 4px;
  width: 24px;      /* scale down the 48×48 PNG */
  height: 24px;
  pointer-events: none;
  z-index: 2;
  background-color: rgba(255, 255, 255, 0.5);
  border-radius: 3px;
}

#overlay{position:fixed;inset:0;display:none;align-items:center;justify-content:center;
         background:rgba(0,0,0,.8);z-index:10000}
#overlay.visible{display:flex}
#overlay img,#overlay video{max-width:90vw;max-height:min(87vh, calc(100% - 30px));  
  position: absolute; top:49.5%; transform:translateY(-50%);
  
  width: auto;
  height: auto;
  aspect-ratio: auto;
  object-fit: contain;border-radius:8px}
#timestamp{position:absolute;top:1rem;left:50%;transform:translateX(-50%);
           color:#fff;font-size:1.1rem;font-weight:600; text-align: center;z-index:10001; text-shadow: 1px 1px 5px black;}
#downloadBtn{position:fixed;bottom:0.75rem;left:50%;transform:translateX(-50%);
             padding:.6rem 1.2rem;background:#fff;border:1px solid #444;border-radius:6px;
             cursor:pointer;font-weight:600;z-index:10001;color:black;}

/* full-screen loader */
#loader {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255,255,255,0.8);
  z-index: 100000;
}
/* circular throbber */
.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid #ccc;
  border-top-color: var(--primary-color);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}
@keyframes spin {
  to { transform: rotate(360deg); }
}


</style>
</head>
<body>
<div id="loader">
  <div class="spinner"></div>
</div>
<div id="dateIndicator"></div>

<header>
  <label id="addBtn" for="filePicker">Add Photos / Videos</label>
  <!--Add this to input maybe: capture="environment" -->
  <input
    id="filePicker"
    type="file"
    multiple
    accept="image/*,video/*"
    style="width:0; height:0; opacity:0; overflow:hidden;">
</header>

<div id="tabs" class="tabs">
  <div id="tabAll"  class="tab-header active">All Uploads</div>
  <div id="tabMine" class="tab-header">My Uploads</div>
  <span class="glider"></span>
</div>

<section id="panelAll"  class="tab-panel active"></section>
<section id="panelMine" class="tab-panel"></section>
<!-- <footer id="loadMoreContainer" style="text-align:center; padding:1rem;">
  <button id="loadMoreBtn" style="background-color: var(--primary-color);color: white;margin:0;padding:0.5rem 1rem;cursor:pointer;font-size:1rem; border-radius: 8px; border: none;font-weight: 700;">Load more</button>
</footer> -->

<div id="selectionToolbar">
  <button id="deleteSelected">Delete</button>
  <button id="downloadSelected">Download</button>
  <span id="deselectAll">&times;</span>
</div>

<div id="overlay">
  <div id="timestamp"></div>
</div>
<button id="downloadBtn" style="display:none">Download</button>

<script type="module">
// ── AWS config ─────────────────────────────────────────────────────────────
const REGION  = "us-west-2";
const ID_POOL = "us-west-2:8e34a4e5-741b-402e-9bfb-eeb90b5643e3";
const BUCKET  = "weddingphotos-2025";

import { parse } from
  "https://cdn.jsdelivr.net/npm/exifr@7.1.3/dist/full.esm.mjs"; 
import {
  S3Client, ListObjectsV2Command, PutObjectCommand, HeadObjectCommand, DeleteObjectCommand
} from "https://esm.sh/@aws-sdk/client-s3@3.569.0?bundle&target=es2020&conditions=browser";
import { fromCognitoIdentityPool }
  from "https://esm.sh/@aws-sdk/credential-provider-cognito-identity@3.569.0?bundle&target=es2020&conditions=browser";

import JSZip from 'https://esm.sh/jszip@3.10.1';


let uploading = false;


// NEW: scroll indicator logic
const dateIndicator = document.getElementById('dateIndicator');
let indicatorTimeout;

function showDateIndicator(text) {
  dateIndicator.textContent = text;
  dateIndicator.style.opacity = '1';
  clearTimeout(indicatorTimeout);
  indicatorTimeout = setTimeout(() => {
    dateIndicator.style.opacity = '0';
  }, 1000);
}

function onScroll() {
  const panel   = document.querySelector('.tab-panel.active');
  const figures = Array.from(panel.querySelectorAll('figure'));

  for (let fig of figures) {
    const rect = fig.getBoundingClientRect();
    // first one whose center has scrolled into view…
    if (rect.top + rect.height/2 >= 100) {
      const ts = new Date(Number(fig.dataset.taken));
      const opts = {
        year:  'numeric',
        month: 'short',
        day:   '2-digit',
        hour:   '2-digit',
        minute: '2-digit',
        hour12: false
      };
      showDateIndicator(ts.toLocaleString('en-US', opts));
      break;
    }
  }
}

document.getElementById('panelAll').addEventListener('scroll', onScroll);
document.getElementById('panelMine').addEventListener('scroll', onScroll);

// ensure overflow scroll on panels
document.querySelectorAll('.tab-panel').forEach(p => {
  p.style.overflowY = 'auto';
});


// 0) prevent “exit on back” by having an initial state
history.replaceState({ view: 'main' }, '');
window.addEventListener('popstate', (e) => {
  if (overlay.classList.contains('visible')) {
    closeOverlay();
  }
});




// set up the selection toolbar
const selectedKeys = new Set();
const toolbar       = document.getElementById('selectionToolbar');
const btnDownload   = document.getElementById('downloadSelected');
const btnDelete     = document.getElementById('deleteSelected');

const btnDeselect = document.getElementById('deselectAll');
btnDeselect.onclick = () => {
  // clear all selections
  document.querySelectorAll('figure.selected').forEach(f => f.classList.remove('selected'));
  selectedKeys.clear();
  updateToolbar();
};

function updateToolbar() {
  const count = selectedKeys.size;
  if (count === 0) {
    toolbar.style.display = 'none';
    return;
  }
  toolbar.style.display = 'flex';
  btnDownload.textContent = `Download (${count})`;

  // only show Delete if *all* selectedKeys are in your own set
  const mineSet = mine();
  const allOwned = Array.from(selectedKeys).every(key => mineSet.has(key));
  btnDelete.style.display = allOwned ? 'inline-block' : 'none';
  btnDelete.textContent = allOwned
    ? `Delete (${count})`
    : '';
}





const s3 = new S3Client({
  region: REGION,
  credentials: fromCognitoIdentityPool({ identityPoolId: ID_POOL, clientConfig:{region:REGION}})
});

// ── use localStorage instead of cookies ────────────────────────────────────
function getUploads(){
  try { return JSON.parse(localStorage.getItem("myUploads") || "[]"); }
  catch { return []; }
}
function saveUploads(arr){
  localStorage.setItem("myUploads", JSON.stringify(arr));
}
function remember(key){
  const arr = getUploads();
  if (!arr.includes(key)) {
    arr.push(key);
    saveUploads(arr);
  }
}
function mine(){
  return new Set(getUploads());
}

// ── DOM refs & tabs ───────────────────────────────────────────────────────
const picker    = document.getElementById('filePicker');
const addBtn    = document.getElementById('addBtn');
const panelAll  = document.getElementById('panelAll');
const panelMine = document.getElementById('panelMine');
const tabAll    = document.getElementById('tabAll');
const tabMine   = document.getElementById('tabMine');
const overlay   = document.getElementById('overlay');
const tsLabel   = document.getElementById('timestamp');
const dlBtn     = document.getElementById('downloadBtn');
const loader    = document.getElementById('loader');

tabAll.addEventListener('pointerdown', () => switchTab(true));
tabMine.addEventListener('pointerdown', () => switchTab(false));

function switchTab(showAll){
  tabAll.classList.toggle('active',  showAll);
  tabMine.classList.toggle('active', !showAll);
  panelAll.classList.toggle('active',  showAll);
  panelMine.classList.toggle('active', !showAll);

  localStorage.setItem('activeTab', showAll ? 'all' : 'mine');
  dateIndicator.style.opacity = '0';
  updatePanelMessages();
}

// ── restore last-active tab on load ──────────────────────────────────────
const last = localStorage.getItem('activeTab');
if (last === 'mine') {
  switchTab(false);
} else {
  switchTab(true);
}

// ── upload flow ──────────────────────────────────────────────────────────
// wrap your picker.onchange to show progress
picker.onchange = async ev => {
  // console.log("picker.onchange", ev);
  const files = Array.from(ev.target.files);
  if (files.length === 0) return;

  // start the overlay
  uploading = true;
  overlay.innerHTML = `
    <div style="
      color: white;
      font-size: 1.2rem;
      text-align: center;
      padding: 1rem;
    ">
      Uploading 0 / ${files.length}…
    </div>
  `;
  overlay.classList.add('visible');

  const newKeys = [];
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const key = `${Date.now()}_${file.name}`;

    // Prepare metadata
    const exifDate = await getExifDateFromFile(file);
    const meta     = {};
    if (exifDate) {
      // store as ISO so it sorts and reads nicely
      meta.taken = exifDate.toISOString();
    }

    // perform upload
    await s3.send(new PutObjectCommand({
      Bucket:      BUCKET,
      Key:         key,
      Body:        file,
      ContentType: file.type,
      Metadata: meta,
    }));

    // remember & track
    remember(key);
    newKeys.push(key);

    // update overlay progress
    const prog = overlay.querySelector('div');
    prog.textContent = `Uploading ${i+1} / ${files.length}…`;
  }

  overlay.innerHTML = `<div style="color: white; font-size: 1.2rem; text-align: center; padding: 1rem;">
    Uploaded ${files.length} / ${files.length}<br>Success!!
  </div>`;
  await new Promise(resolve => setTimeout(resolve, 1000));

  // done!
  uploading = false;
  overlay.classList.remove('visible');
  picker.value = "";

  // finally append new thumbnails
  await appendNew(newKeys);
};

// ── overlay & download ────────────────────────────────────────────────────
let currentSrc = "", currentName = "";
function openOverlay(src, isVideo, _tsReadable, fileName) {
  // 1) Find the <figure> whose lazy-loaded img/video src matches
  const selector = isVideo
    ? `video[src="${src}"]`
    : `img[src="${src}"]`;
  const mediaEl = document.querySelector(selector);
  let dateMs = Date.now();
  if (mediaEl) {
    const fig = mediaEl.closest('figure');
    if (fig && fig.dataset.taken) {
      dateMs = Number(fig.dataset.taken);
    }
  }

  // 2) Format the timestamp freshly
  const ts = new Date(dateMs);
  const timePart = ts.toLocaleTimeString("en-US", {
    hour:   "2-digit",
    minute: "2-digit",
    hour12: false
  });
  const datePart = ts.toLocaleDateString("en-US", {
    month: "short",
    day:   "2-digit",
    year:  "numeric"
  });
  const formatted = `${timePart}, ${datePart}`;

  // 3) Build the overlay
  currentSrc  = src;
  currentName = fileName;
  overlay.innerHTML = "";
  tsLabel.textContent = formatted;
  overlay.appendChild(tsLabel);
  overlay.appendChild(
    isVideo
      ? Object.assign(document.createElement('video'), { src, controls: true })
      : Object.assign(document.createElement('img'),   { src      })
  );
  overlay.classList.add('visible');
  dlBtn.style.display = 'block';

  // 4) Push history so ESC/back closes it
  history.pushState({ view: 'overlay' }, '');
}

function closeOverlay(){
  // console.log("closeOverlay");
  /* ① stop video if one is present */
  const vid = overlay.querySelector('video');
  if (vid) {
    vid.pause();
    vid.currentTime = 0;
  }

  if (history.state?.view === 'overlay') {
    history.back(); // pops the “overlay” entry off the stack
  }

  overlay.classList.remove('visible');
  dlBtn.style.display = 'none';
}
// listen for pointerdown on the overlay background:
overlay.onclick = null;
overlay.addEventListener('pointerup', e => {
  if (uploading) return;
  if (e.target === overlay) {
    e.stopPropagation();
    closeOverlay();
  }
});
window.addEventListener('keydown', e => {
  if (uploading && e.key === 'Escape') return;
  if (e.key === 'Escape') closeOverlay();
});

// Add a pointerdown listener instead
dlBtn.addEventListener('pointerdown', async () => {
  dlBtn.disabled    = true;
  dlBtn.textContent = "Downloading…";

  try {
    const resp = await fetch(currentSrc);
    const blob = await resp.blob();
    const url  = URL.createObjectURL(blob);
    const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

    if (isMobile) {
      // On mobile, open blob URL in a new tab so user can save it manually
      window.open(url, '_blank');
    } else {
      // On desktop, use download attribute
      const a = document.createElement('a');
      a.href        = url;
      a.download    = currentName;
      document.body.appendChild(a);
      a.click();
      a.remove();
    }

    // give the browser a moment to spin up the download
    setTimeout(() => URL.revokeObjectURL(url), 500);
  } finally {
    dlBtn.disabled    = false;
    dlBtn.textContent = "Download";
  }
});



// ── gallery render (newest→oldest) ───────────────────────────────────────
// ── lazy-load observer ─────────────────────────────────────────────────────
// 👉 replace your existing observer with this

/* --------------------------------------------------------------
 * Smarter lazy-loader
 *   – max 4 concurrent downloads
 *   – always loads the tile closest to the viewport first
 * -------------------------------------------------------------- */
const MAX_CONCURRENT = 4;
let   inFlight       = 0;
const queue          = new Set();              // <img>/<video> waiting to load

function distanceToViewportCenter(rect) {
  const vpCenter = window.innerHeight / 2;
  return Math.abs((rect.top + rect.bottom) / 2 - vpCenter);
}

function processQueue() {
  if (inFlight >= MAX_CONCURRENT || queue.size === 0) return;

  // pick the element whose centre is *closest* to the viewport centre
  let bestEl = null, bestDist = Infinity;
  for (const el of queue) {
    const dist = distanceToViewportCenter(el.getBoundingClientRect());
    if (dist < bestDist) { bestDist = dist; bestEl = el; }
  }
  if (!bestEl) return;

  queue.delete(bestEl);
  startLoading(bestEl);
}

function startLoading(el) {
  inFlight++;
  if ('fetchPriority' in el) el.fetchPriority = 'high';

  el.src = el.dataset.src;
  if (el.tagName === 'VIDEO') el.load();       // kick off the video download

  const done = () => {
    inFlight--;
    processQueue();                            // start the next one
  };

  const eventName = el.tagName === 'VIDEO' ? 'loadeddata' : 'load';
  el.addEventListener(eventName, done,  { once: true });
  el.addEventListener('error',      done,  { once: true });
}

/* ------------ IntersectionObserver ---------------------------- */
const OBS_MARGIN    = '0px 0px 400px 0px';     // only look *below* viewport
const VIS_THRESHOLD = 0.15;                    // 15 % visible ⇒ queue

const io = new IntersectionObserver(entries => {
  for (const entry of entries) {
    const el = entry.target;

    if (entry.isIntersecting && entry.intersectionRatio >= VIS_THRESHOLD) {
      // in range  →  queue it (unless already queued / loaded)
      if (!el.dataset.queued && !el.src) {
        el.dataset.queued = '1';
        if ('fetchPriority' in el) el.fetchPriority = 'low';     // until it’s up
        queue.add(el);
        processQueue();
      }
    } else {
      // out of range again  →  drop from queue if not started yet
      if (queue.delete(el)) delete el.dataset.queued;
    }
  }
}, { rootMargin: OBS_MARGIN, threshold: VIS_THRESHOLD });



// ── paging variables ───────────────────────────────────────────────────────
const batchSize = 10;
let loadedCount = batchSize;
// const loadMoreBtn = document.getElementById('loadMoreBtn');
// loadMoreBtn.onclick = () => {
//   loadedCount += batchSize;
//   render();
// };


/* ---------- FAST DATE HELPERS ---------------------------------- */
// Use LastModified immediately; refine with EXIF later (images only)
function quickDate(obj) {
  return new Date(obj.LastModified);         // ✔ already in ListObjects
}


async function refineDate(key, origDate) {
  // 1) Videos don’t carry EXIF
  if (/\.(mp4|mov|webm)$/i.test(key)) {
    return origDate;
  }

  const url = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${encodeURIComponent(key)}`;
  const exifDate = await getExifDateFromFile(url);
  return exifDate || origDate;
}


/* ---------- RENDER ---------------------------------------------- */
async function render() {
  loader.style.display = 'flex';      // show spinner

  // 1. cheap list call
  const { Contents = [] } = await s3.send(
    new ListObjectsV2Command({ Bucket: BUCKET })
  );

  // 2. build a “raw” index using LastModified first
  const index = Contents.map(obj => ({
    Key: obj.Key,
    takenDate: quickDate(obj)
  }))
  .sort((a, b) => b.takenDate - a.takenDate);

  const mySet = mine();

  /* -------- NEW: paint with **refined** dates right away -------- */
  const firstScreen = 50;
  for (let i = 0; i < Math.min(firstScreen, index.length); i++) {
    const { Key, takenDate } = index[i];
    const refined = await refineDate(Key, takenDate);   // 🔍 EXIF first
    index[i].takenDate = refined;                       // keep book-keeping tidy
    await buildFigure(Key, refined, mySet);             // ⬅️ insertSorted() inside
  }

  loader.style.display = 'none';      // spinner off

  /* 4. stream the rest, but refine *before* insertion */
  (async function streamRest() {
    const chunk = 200; // The smaller chunk saves mobile data, but loads slower
    for (let i = firstScreen; i < index.length; i += chunk) {
      await Promise.all(
        index.slice(i, i + chunk).map(async ({ Key, takenDate }) => {
          const refined = await refineDate(Key, takenDate);
          await buildFigure(Key, refined, mySet);        // already sorted
        })
      );
      await new Promise(r => setTimeout(r, 0));         // yield to UI
    }
  })();
}


/* ---------- helpers -------------------------------------------------- */
// add a data-attribute that we can sort on
function tagWithTaken(fig, date) {
  fig.dataset.taken = String(date.getTime());   // newest → largest number
}

// (re)sort all children in a panel by that attribute (DESC)
function sortPanel(panel) {
  // console.log("sortPanel start", panel.id);
  [...panel.children]                       // live HTMLCollection → array
    .sort((a, b) => Number(b.dataset.taken) - Number(a.dataset.taken))
    .forEach(el => panel.appendChild(el));  // re-append in correct order
  // console.log("sortPanel end", panel.id);
}

function insertSorted(panel, fig) {
  const newVal = Number(fig.dataset.taken);
  for (const child of panel.children) {
    if (Number(child.dataset.taken) < newVal) {
      panel.insertBefore(fig, child);   // drop it just before the first “older” one
      return;
    }
  }
  panel.appendChild(fig);               // all others are newer → append at the end
  updatePanelMessages();
}

// quickly wire clone → delete handler
function rewireDelete(origFig, cloneFig) {
  const o = origFig.querySelector('.del');
  const c = cloneFig.querySelector('.del');
  if (o && c) c.onclick = o.onclick;
}

async function appendNew(keys) {
  // // if we had a “no uploads” message showing, get rid of it now
  // document.querySelectorAll('p.empty-message').forEach(el => el.remove());

  const me = mine();

  for (const Key of keys) {
    // head + EXIF → takenDate
    const head      = await s3.send(new HeadObjectCommand({ Bucket: BUCKET, Key }));

    let takenDate;
    if (head.Metadata?.taken) {
      takenDate = new Date(head.Metadata.taken);
    } else {
      takenDate = await getExifDateFromURL(Key, head.LastModified);
    }

    /* build but DON’T append yet */
    const fig = await buildFigure(Key, takenDate, me);

    loadedCount++;              // keep paging logic happy
  }

  /* finally: re-sort both panels so the new items land in place */
  sortPanel(panelAll);
  sortPanel(panelMine);

  updatePanelMessages();

  // /* update "Load more" visibility */
  // const { Contents = [] } = await s3.send(new ListObjectsV2Command({ Bucket: BUCKET }));
  // loadMoreBtn.style.display = loadedCount < Contents.length ? 'inline-block' : 'none';
}

// 1) keep your File-based EXIF extractor as-is (but rename it to a generic "source")
/**
 * Try to read all common EXIF date tags from a File or URL,
 * then return whichever is the oldest.
 */
async function getExifDateFromFile(source) {
  try {
    // ask exifr for all the date fields it knows
    const exif = await parse(source, [
      "DateTimeOriginal",
      "CreateDate",
      "ModifyDate",
      "DocumentName",       // sometimes JPEGs store edit dates here
      "GPSTimeStamp"        // only for geo‐tagged images
    ]) || {};

    // collect only actual Date instances
    const dates = [
      exif.DateTimeOriginal,
      exif.CreateDate,
      exif.ModifyDate,
      exif.GPSTimeStamp
    ]
    .filter(d => d instanceof Date)
    .map(d => d.getTime());

    if (dates.length === 0) {
      return null;
    }

    // find the smallest (oldest) timestamp
    const oldestMs = Math.min(...dates);
    return new Date(oldestMs);

  } catch (err) {
    console.warn("EXIF parse failed for", source, err);
    return null;
  }
}


// 2) URL variant simply reuses the above
async function getExifDateFromURL(key, fallbackMs) {
  // Skip videos — they won’t have EXIF
  if (/\.(mp4|mov|webm)$/i.test(key)) {
    return new Date(fallbackMs);
  }

  const url = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${encodeURIComponent(key)}`;
  const exifDate = await getExifDateFromFile(url);
  if (exifDate) {
    return exifDate;
  }

  // fallback to S3’s LastModified timestamp
  return new Date(fallbackMs);
}


async function buildFigure(Key, takenDate, mySet) {
  const url        = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${encodeURIComponent(Key)}`;
  const isMine     = mySet.has(Key);
  const isVideo    = /\.(mp4|mov|webm)$/i.test(Key);
  const timePart = takenDate.toLocaleTimeString("en-US", {
    hour:   "2-digit",
    minute: "2-digit",
    hour12: false
  });
  const datePart = takenDate.toLocaleDateString("en-US", {
    month: "short",
    day:   "2-digit",
    year:  "numeric"
  });
  const tsReadable = `${timePart}, ${datePart}`;

  // build the figure
  const fig = document.createElement('figure');
  fig.style.touchAction = 'manipulation';             // for better pointer behavior
  fig.addEventListener('contextmenu', e => e.preventDefault());  // block long-press menu
  fig.dataset.key = Key;
  tagWithTaken(fig, takenDate);
  fig.style.cursor = 'pointer';
  
  // thumbnail or video placeholder
  if (isVideo) {
    const v = document.createElement('video');
    v.muted = true; v.controls = false; v.preload = 'none';
    v.dataset.src = url;
    fig.appendChild(v);
    io.observe(v);

    // add video icon
    const icon = document.createElement('img');
    icon.src   = 'https://img.icons8.com/fluency-systems-regular/48/video.png';
    icon.alt   = 'video';
    icon.className = 'video-icon';
    fig.appendChild(icon);
  } else {
    const img = document.createElement('img');
    img.loading   = 'lazy';
    img.dataset.src = url;
    fig.appendChild(img);
    io.observe(img);
  }

  // add selection box to every item
  const box = document.createElement('div');
  box.className = 'select-box';
  fig.appendChild(box);

  function wireSelectionHandlers(fig) {
    // block just the native long-press menu
    fig.addEventListener('contextmenu', e => e.preventDefault());

    // --- LONG-PRESS SELECTION HANDLERS ---
    let longPress = false;
    let lpTimer;

    // on touch/pen/mouse down, start the 500ms timer
    fig.addEventListener('pointerdown', e => {
      lpTimer = setTimeout(() => {
        longPress = true;       
        toggleSelection(Key);
      }, 600);
    });

    // on any exit or up, clear the timer
    fig.addEventListener('pointerup', e => {
      // console.log("pointerup", e);
      clearTimeout(lpTimer);
      if (longPress) {
        longPress = false;
      } else if (e.target.className === "select-box" || selectedKeys.size > 0) {
        toggleSelection(Key);
      } else {
        openOverlay(url, isVideo, tsReadable, Key.split('/').pop());
      }
    });


    ['pointercancel'].forEach(evt =>
      fig.addEventListener(evt, () => {
        clearTimeout(lpTimer);
      })
    );
  }

  // always add to “All”
  wireSelectionHandlers(fig);
  insertSorted(panelAll, fig);

  // if it’s mine, clone *and* re-attach handlers for “My Uploads”
  if (isMine) {
    // Clone the figure for the “My Uploads” pane
    const clone = fig.cloneNode(true);

    // 0) get the original box and the clone's box
    const origBox  = fig.querySelector('.select-box');
    const cloneBox = clone.querySelector('.select-box');
    // 1) re-bind the click handler
    if (origBox && cloneBox) {
      cloneBox.onclick = origBox.onclick;
    }

    // 1) Re-attach lazy-load observer to the cloned thumb
    const thumb = clone.querySelector('img, video');
    if (thumb) io.observe(thumb);

    // 2) Re-bind the click to openOverlay
    clone.onclick = fig.onclick;

    // 3) Swap out the delete button’s handler to just open (no delete)
    const origDel  = fig .querySelector('.del');   // original delete handler
    const cloneDel = clone.querySelector('.del');  // delete in My Uploads
    if (origDel && cloneDel) {
      cloneDel.onclick = origDel.onclick;          // give it *the same* handler
    }

    wireSelectionHandlers(clone);
    insertSorted(panelMine, clone);
  }

  return fig;
}

// pull out your selection logic so it’s easy to call from both tap and long-press
function toggleSelection(Key) {
  const was = selectedKeys.has(Key);
  if (was) selectedKeys.delete(Key);
  else        selectedKeys.add(Key);

  // update *all* cloned figures for this Key
  document.querySelectorAll(`figure[data-key="${Key}"]`).forEach(fig =>
    fig.classList.toggle('selected', !was)
  );
  updateToolbar();
}

// initial render
render();


// 1) Download Selected
btnDownload.onclick = async () => {
  btnDownload.textContent = "Downloading...";
  btnDownload.disabled = true;

  if (selectedKeys.size === 0) return;
  const keys = Array.from(selectedKeys);
  if (keys.length === 1) {
    // single file: just fetch & download
    const url = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${encodeURIComponent(keys[0])}`;
    const resp = await fetch(url);
    const blob = await resp.blob();
    const a    = Object.assign(document.createElement('a'), {
      href: URL.createObjectURL(blob),
      download: keys[0].split('_').slice(1).join('_')
    });
    document.body.appendChild(a);
    a.click();
    a.remove();
  } else {
    // multiple: zip them
    const zip = new JSZip();
    await Promise.all(keys.map(async key => {
      const url  = `https://${BUCKET}.s3.${REGION}.amazonaws.com/${encodeURIComponent(key)}`;
      const resp = await fetch(url);
      const blob = await resp.blob();
      zip.file(key.split('_').slice(1).join('_'), blob);
    }));
    const content = await zip.generateAsync({ type: 'blob' });
    const a = Object.assign(document.createElement('a'), {
      href: URL.createObjectURL(content),
      download: 'maiya-jared-2025.zip'
    });
    document.body.appendChild(a);
    a.click();
    a.remove();
  }
  btnDownload.textContent = `Download (${selectedKeys.size})`;
  btnDownload.disabled = false;
};

// 2) Delete Selected
btnDelete.onclick = async () => {
  btnDelete.textContent = "Deleting...";
  btnDelete.disabled = true;

  const count = selectedKeys.size;
  if (!confirm(`Are you sure you want to delete ${count} file${count>1?'s':''}?`)) {
    btnDelete.disabled = false;
    btnDelete.textContent = `Delete (${selectedKeys.size})`;
    return;
  }
  // perform deletes in parallel
  await Promise.all(
    Array.from(selectedKeys).map(key =>
      s3.send(new DeleteObjectCommand({ Bucket: BUCKET, Key: key }))
    )
  );

  // remove the nodes
  for (const key of Array.from(selectedKeys)) {
    document
      .querySelectorAll(`figure[data-key="${key}"]`)
      .forEach(fig => fig.remove());
  }
  selectedKeys.clear();
  updateToolbar();

  // ── NEW: re-check for empty panels ─────────────────────────────────
  updatePanelMessages();
  // ────────────────────────────────────────────────────────────────────

  btnDelete.textContent = `Delete (${selectedKeys.size})`;
  btnDelete.disabled = false;
};


function updatePanelMessages() {
  function updateEmptyMessage(panel) {
    if (!panel.querySelector('figure')) {
      panel.innerHTML = "<p class='empty-message'>No uploads yet</p>";
    } else {
      panel.querySelector('.empty-message')?.remove();
    }
  }

  updateEmptyMessage(panelAll);
  updateEmptyMessage(panelMine);
}


// --- add “Select All” via Ctrl+A / ⌘+A, but only inside the active panel ---
window.addEventListener('keydown', e => {
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'a') {
    e.preventDefault();

    // find the active panel
    const activePanel = document.querySelector('.tab-panel.active');
    if (!activePanel) return;

    // select every figure in that panel
    activePanel
      .querySelectorAll('figure[data-key]')
      .forEach(fig => {
        const key = fig.dataset.key;
        if (!selectedKeys.has(key)) {
          toggleSelection(key);
        }
      });
  }
});

</script>
</body>
</html>
